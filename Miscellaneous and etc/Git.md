
![[Pasted image 20240626080136.png]]
# Commands
## Reset
Allows you to unstage changes, if you don't want to revert all files from add
```
git add .
gir reset
```
## Add
Stages changes for commit
```
git add .
```
## Status
Shows staged files
```
git status
```
## Commit
Commits changes to repo
```
git commit -m "Initial commit"
```
Also in case of bad commit messafe we can always go and change it if it wasn't already pushed
```
git commit --amend -m "update latest!"
```
Or if you forgot to add some files
```
git add something
git commit --amend --no-edit
```
## Branches
List of branches

```
git branch
```

Create a new branch

```
git branch branch-name
```

Checkout the branch

```
git checkout dev
```

You can also checkout the specific file the same way
## Remotes
We can add remote but often you will just add remote via upsteam when adding a branch

```shell
git remote add ...
git branch -u origin new-feature
```

## Push

When we want to push a repo to our remote origin

```
git push
```
What if we already pushed the wrong commit?
```
git push origin master --force
```
will overwrite the last commit on remote
What if you push the code which shoul have never ever been there?
```
git revert 
```
Saves the commit but reverts the state
## Merging

```
git checkout dev
git merge main
```
We can cancel the merge operation
```
git merge --abort
```
## Stashing
В процессе написания кода может возникнуть ситуация, когда нужно срочно переключиться на другую ветку (использовать git checkout) — или, например, внести правки, которые относятся к другой задаче. Однако новые изменения еще не готовы к тому, чтобы их коммитить и добавлять в репозиторий, — при этом терять их нельзя. В таком случае, как и во многих других, полезной окажется команда git stash.

```
git stash list
git stash
git stash save my-name
git stash apply
git stash pop

git stash list
```
**Git stash** перемещает текущие изменения (так называемые local changes) в локальную директорию, которая выполняет роль специального хранилища, то есть скрывает эти изменения, сохраняя их отдельно, с опцией вернуть позже, когда это понадобится
Сейчас команда **git stash save** считается неактуальной, ее более полезная замена — **git stash push**. Вызвано это прежде всего тем, что, выполняя **git stash push**, можно сохранять определенные спецификации пути. Это, к сожалению, не поддерживается **git stash save**. **Git stash save** все еще работает, но в будущем следует ожидать постепенного перехода на **git stash push** из-за доступности нового функционала.
```
git stash pop
```
После выполнения в хранилище очищаются изменения и возвращаются к рабочей копии. Если же необходимо, чтобы изменения остались (то есть не удалились из хранилища), но при этом вернулись в проект, мы применим **git stash apply**

Этим полезно пользоваться, когда одни и те же части кода нужны для корректной работы нескольких веток — или в том случае, если необходимо удалить ветку, в которой изначально были сделаны эти изменения. Тогда можно автоматически перенести желаемые участки кода.

`git branch --delete <name of branch>`

## Show author
To show the line author type:
```
git blame
```
## Diff
To show the changes made after the last commit
```
git diff
```

## Log
```
git log --graph --oneline --decorate
```

## Bisect

## Rebase + Squash + fixup
```
git rebase master --interactive
```


# Tips

## 1. Параметры для удобного просмотра лога

```
**git log --oneline --graph**
```

- **--author="Alex Kras"** — выводит коммиты, сделанные конкретным человеком
- **--name-only** — выводит только названия изменённых файлов
- **--oneline** — выводит сокращённые данные коммита (в виде одной строки)
- **--graph** — выводит дерево зависимостей для всех коммитов
- **--reverse** — выводит коммиты в обратном хронологическом порядке (сначала старые)
- **--after** — выводит коммиты, сделанные после определённой даты
- **--before** — выводит коммиты, сделанные до определённой даты

  
Вообще, в Git есть много всяких полезных параметров. Просто попробуйте выполнить **man git-log** чтобы посмотреть все варианты просмотра истории. Если ни один из предложенных вариантов вас не устроит, вы всегда можете воспользоваться параметром **--pretty**, с помощью которого можно настраивать выдачу в широких пределах.


## 2. Вывод актуальных изменений в файл

Пример команды: **git log -p filename**  
  
С помощью команд **git log -p** или **git log -p filename** можно посмотреть не только примечание к коммиту, автора и дату, но также сделанные в этом коммите изменения.

## 3. Просмотр изменений в определённых строках файла

Пример команды: **git log -L 1,1:some-file.txt**

С помощью команды **git blame filename** можно определить автора последних изменений для каждой строки в файле.

## 4. Просмотр ещё не влитых в родительскую ветку изменений

Пример команды: **git log --no-merges master..**

Если вам приходилось работать с долгоживущими ветками, над которыми трудится много людей, то вы наверняка сталкивались с множественными вливаниями (мёржами) родительской ветки (например, master) в ветку с разрабатываемой фичей. Такие мёржи затрудняют просмотр истории изменений рабочей ветки, потому что будет сложно отличить коммиты, сделанные в родительской ветке от коммитов рабочей ветки.

Команда **git log --no-merges master..** решает эту проблему: параметр **--no-merges** говорит, что нужно показать коммиты, которые ещё не были вмёржены куда-либо, а параметр **master..** говорит, что нужно показать только те изменения, которые ещё не были вмёржены в ветку master (здесь важно обратить внимание на две точки после названия ветки).

## 5. Извлечение файла из другой ветки

Пример команды: **git show some-branch:some-file.js**

Иногда бывает удобно посмотреть на какой-либо файл в другой ветке, не переключаясь на неё. Это можно сделать с помощью команды **git show some-branch-name:some-file-name.js**, которая выведет содержимое файла в указанной ветке прямо в терминал.

А с помощью перенаправления вывода можно сохранить этот файл в указанное место на диске, например, если вы заходите открыть два файла одновременно в своём редакторе: **git show some-branch-name:some-file-name.js > deleteme.js**.

Примечание: если вам нужно всего лишь сравнить два файла, то можно выполнить такую команду: **git diff some-branch some-filename.js**

## 6. Пара слов о ребейзе

Пример команды: **git pull --rebase**
Ранее мы говорили о многочисленных мёржах мастера в рабочую ветку. Некоторых из них можно избежать, используя команду **git rebase**

Например, вы работаете с локальной копией ветки и сделали небольшой коммит. А в это время кто-то ещё залил в удалённую копию ветки результаты своего недельного труда. Когда вы попытаетесь запушить свои изменения, Git скажет вам, что он не может это сделать, и что вам сначала нужно сделать **git pull** для разрешения конфликта. Как добропорядочный человек вы так и поступите и после выполнения команды **git pull** в истории вашей локальной копии ветки получится вот такой вот коммит, сгенерированный автоматически: «Merge remote-tracking branch 'origin/master'».
Это, конечно, не проблема и всё будет работать как нужно, однако такие коммиты засоряют историю изменений. В таких случаях лучше выполнять команду **git pull --rebase**, и Git сначала заберёт изменения из удалённой копии ветки, а потом накатит ваши незапушенные коммиты после самого последнего коммита удалённой ветки, так, как будто бы всё так и было. Таким образом необходимость мёржа отпадает и мы избежим уродливого коммита о мёрже в истории изменения.


## 7. Сохранение структуры ветки после локального мержа

Пример команды: **git merge --no-ff**

